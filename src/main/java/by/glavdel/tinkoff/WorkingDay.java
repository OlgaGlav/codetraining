package by.glavdel.tinkoff;

// У Кати насыщенный день на работе.
// Ей надо передать n разных договоров коллегам.
// Все встречи происходят на разных этажах, а между этажами можно перемещаться только по лестничным пролетам.
// Прохождение каждого пролета занимает ровно 1 минуту.
//
// Сейчас Катя на парковочном этаже, планирует свой маршрут.
// Коллег можно посетить в любом порядке, но один из них покинет офис через t минут.
// С парковочного этажа лестницы нет — только лифт, на котором можно подняться на любой этаж.
//
// В итоге план Кати следующий:
//
//Подняться на лифте на произвольный этаж. Считается, что лифт поднимается на любой этаж за 0 минут.
//Передать всем коллегам договоры, перемещаясь между этажами по лестнице. Считается, что договоры на этаже передаются мгновенно.
//В первые t минут передать договор тому коллеге, который планирует уйти.
//Пройти минимальное количество лестничных пролетов.
//Помогите Кате выполнить все пункты ее плана.
//
//Формат входных данных
//В первой строке вводятся целые положительные числа n и t
// (2≤n,t≤100)  — количество сотрудников и время, когда один из сотрудников покинет офис (в минутах).
// В следующей строке n чисел — номера этажей, на которых находятся сотрудники.
// Все числа различны и по абсолютной величине не превосходят 100.
// Номера этажей даны в порядке возрастания. В следующей строке записан номер сотрудника, который уйдет через t минут.
//
//Формат выходных данных
//Выведите одно число — минимально возможное число лестничных пролетов, которое понадобится пройти Кате.
//
//Замечание
//В первом примере времени достаточно, чтобы Катя поднялась по этажам по порядку.
//
//Во втором примере Кате понадобится подняться к уходящему сотруднику, а потом пройти всех остальных — например,
// в порядке {1,2,3,4,6}
//
//ВВод
//5  5
//1  4  9  16  25
//2,
// вывод 24
//
//ВВод
// 6  4
//1  2  3  6  8  25
//5,
// вывод 31

import java.util.Scanner;

public class WorkingDay {
    public static int quantityContracts;
    public static int timeMinuteEmployeeLeaf;
    public static int[] numberFlor;
    public static int numberEmployeeWhoLeave;

    public static void main(String[] args) {
        System.out.println("Input data ");
        readDataFromConcole();
        int countMinFlow = countMinFlow();
        System.out.println(countMinFlow);
    }

    private static int countMinFlow() {
        int count;
        if (timeMinuteEmployeeLeaf >= numberEmployeeWhoLeave) {
            count = numberFlor[numberFlor.length - 1] - numberFlor[0];
        } else {
            count = (numberFlor[numberEmployeeWhoLeave - 1] - numberFlor[0]) +
                    (numberFlor[numberEmployeeWhoLeave - 1] - numberFlor[timeMinuteEmployeeLeaf - 1]) +
                    (numberFlor[numberFlor.length - 1] - numberFlor[timeMinuteEmployeeLeaf - 1]);
        }
        return count;
    }

    private static void readDataFromConcole() {
        Scanner scanner = new Scanner(System.in);
        quantityContracts = scanner.nextInt();
        timeMinuteEmployeeLeaf = scanner.nextInt();

        numberFlor = new int[quantityContracts];
        for (int i = 0; i < numberFlor.length; i++) {
            numberFlor[i] = scanner.nextInt();
        }

        numberEmployeeWhoLeave = scanner.nextInt();
    }
}
//todo
//Найдем максимум и минимум во входных данных.
//Мы знаем, что ответ не меньше чем max − min. Если нельзя успеть пройти всех сотрудников
//за это время, то это значит, что сотрудник успеет уйти. Тогда выгоднее всего сразу доехать до его
//этажа, а потом сделать одну из двух операций — либо подняться на самый верх, а потом спуститься
//вниз, либо спуститься на самый низ, а потом подняться наверх. Если уезжающий сотрудник был
//на этаже x, то получившимися формулами будет max − min + max − x и max − min + x − min
//соответственно, осталось только найти минимум из этих двух величин.